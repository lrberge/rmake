% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rmake.R
\name{rmake}
\alias{rmake}
\title{Automatically keeps code chunks up to date}
\usage{
rmake(hard = FALSE, ask = TRUE, comment = FALSE, project = NULL, dry = FALSE)
}
\arguments{
\item{hard}{Logical, default is \code{FALSE}. If \code{TRUE}, all code chunks will be run afresh,
as if they were just created.}

\item{ask}{Logical, default is \code{TRUE}. Whether to interactively ask the user whether or
not to run the code that needs to be run.}

\item{comment}{Logical, default is \code{FALSE}. If \code{TRUE}, then anything that should be printed
in the screen when running the code chunks will be inserted, as comments, in the document.
Identical comments are not appended.}

\item{project}{A path to a folder, default is NULL. If provided, \code{rmake} will consider
the path given by \code{project} as the active project. It will then apply to all R files from
this project (not to the current one).}
}
\value{
This function does not return anything. It displays on the console the files
that need to be run, and the reason for running them.
}
\description{
This function first finds the dependencies between chunks of code. Then it runs
the code in a specific order to make all the chunks up to date.
To create code chunks in your R files and benefit from \code{rmake}, see details.
}
\details{
By default \code{rmake} tracks all R files from a given project and tries to find
code chunks within them (see the code chunk section).

\code{rmake} tracks two kind of dependencies. First, file dependencies: if a chunk
uses as input the files that another produced as output. Typical example: one chunk for data
cleaning (output \code{data.tsv}), another for the analysis of this data (input \code{data.tsv}).
Second, function dependencies. All user written functions are tracked. If any of
them is modified, then all chunks that use them are re-run. Please have a look at the section
on input/ouput detection.

\code{rmake} handles indirect dependencies. For example, consider three chunks A, B, and C,
and let's note a dependency with an arrow. Assume A => B => C (C depends on B which
depends on A). Then if A's code is modified \code{rmake} will run the chunks A, then B, then C,
in that specific order.

rmake keeps track of the results in a file located at .rmake/
}
\section{Defining a code chunks}{


\code{rmake} only tracks code chunks which are pieces of code within the R files of a project.
To create a code chunk, use a header comment (i.e. a comment ending with 4 hashes)
that starts with the equal sign (\code{=}).
For example the line \verb{# = data cleaning ####} defines the code chunk named
"data cleaning".

A chunk goes from its starting line to either:
\itemize{
\item the start of another chunk,
\item the end of the R file,
\item an ignored chunk.
}

An ignored chunk is a chunk starting with \code{!=}. For example: \verb{# != dev ####} creates
the ignore chunk "dev". \code{rmake} will ignore everything after that line until if finds
a valid chunk (if there is one).
}

\section{Writing a code chunk}{


When writing a code chunk, keep in mind the following restriction:
A code chunk must be a piece of code that is independent from any other code,
except from functions, and the values contained in the \code{.Rprofile}.
That is: the user should be able to run it without error from a fresh R session.

If your code depends on functions you wrote, simply load them from within the
\code{.Rprofile}. If you don't know what the \code{.Rprofile} is, it is a file whose content
is automatically run during the session's startup.

If your code depends on the data created in other places, save this data on disk
in one chunk, and then load it from disk in another chunk.

You need to decompose the key steps of your processing.
If two pieces of code cannot be separated, it means that they belong to the same chunk.
}

\section{Input output auto detection}{


To automatically detect inputs and outputs, \code{rmakes} uses a trick:
\itemize{
\item all functions with the arguments \code{path} or \code{file} whose result is not assigned is
considered as \code{output}
\item all functions with the arguments \code{path} or \code{file} whose result \emph{is} assigned is
considered as \code{input}
}

For example let's consider the function \code{my_reading_fun(path)}. Then the line
\code{my_reading_fun("test.txt")} is considered as \code{output} by remake because there is
no assignment. Instead, \code{rmake} considers the line \code{data = my_reading_fun("test.txt")}
as \code{input} because there is an assignment.

As you can imagine, even if this guessing works most of the time,
there will always be false positives and false negatives (inputs considered as output,
vice versa, or input/outputs not tracked at all).
}

\examples{

# rmake only works project wise, so for this example:
#  1) we create a project in a temp folder with a few files
#  2) we apply rmake to this mock project

# Note that in general, rmake should only be called as rmake()
# The example below is artificial, only for illustration

#
# We create a project in a temporary directory
# The project contains one R file with two chunks

code = "
# = data creation ####
set.seed(0)
n = 100
base = data.frame(x = rnorm(n))
beta = 1
base$y = 1 + beta * base$x + rnorm(n)

# we save this data set
saveRDS(base, 'data_example.rds')

# = estimation ####

# we load the data from disk
base = readRDS('data_example.rds')

est = lm(y ~ x, base)

# we save the result
saveRDS(summary(est), 'estimation.rds')
"

proj_dir = tempdir()
writeLines(code, file.path(proj_dir, "example.R"))

# we run rmake on this project
if(interactive()){
  rmake(project = proj_dir)
} else {
  rmake(project = proj_dir, ask = FALSE)
}

# let's read the estimation
readRDS(file.path(proj_dir, "estimation.rds"))

# now let's change the code of the first chunk: we change beta
writeLines(sub("beta = 1", "beta = 2", code), file.path(proj_dir, "example.R"))

# rmake re-runs the code that needs to be run
if(interactive()){
  rmake(project = proj_dir)
} else {
  rmake(project = proj_dir, ask = FALSE)
}

# let's see if it worked:
readRDS(file.path(proj_dir, "estimation.rds"))


}
